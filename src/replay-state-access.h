// Copyright Cartesi and individual authors (see AUTHORS)
// SPDX-License-Identifier: LGPL-3.0-or-later
//
// This program is free software: you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option) any
// later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
// PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License along
// with this program (see COPYING). If not, see <https://www.gnu.org/licenses/>.
//

#ifndef REPLAY_STATE_ACCESS_H
#define REPLAY_STATE_ACCESS_H

/// \file
/// \brief State access implementation that replays recorded state accesses

#include <cassert>
#include <iomanip>
#include <sstream>

#include "i-state-access.h"
#include "machine-merkle-tree.h"
#include "machine.h"
#include "shadow-state.h"
#include "unique-c-ptr.h"

namespace cartesi {

/// \brief Allows replaying a uarch reset operation from an access log.
class replay_state_access : public i_state_access<replay_state_access, pma_entry> {
    using tree_type = machine_merkle_tree;
    using hash_type = tree_type::hash_type;
    using hasher_type = tree_type::hasher_type;
    using proof_type = tree_type::proof_type;

    ///< Access log generated by log_uarch_reset
    const std::vector<access> &m_accesses; // NOLINT(cppcoreguidelines-avoid-const-or-ref-data-members)
    ///< Whether to verify proofs in access log
    bool m_verify_proofs;
    ///< Index of next access to ne consumed
    unsigned m_next_access;
    ///< Add to indices reported in errors
    int m_one_based;
    ///< Root hash before next access
    machine_merkle_tree::hash_type m_root_hash;
    ///< Hasher needed to verify proofs
    machine_merkle_tree::hasher_type m_hasher;

public:
    /// \brief Constructor from access log
    /// \param log Access log to be replayed
    /// \param verify_proofs Whether to verify proofs in access log
    /// \param initial_hash Initial root hash
    /// \param one_based Whether to add one to indices reported in errors
    explicit replay_state_access(const access_log &log, bool verify_proofs, const hash_type &initial_hash,
        bool one_based) :
        m_accesses(log.get_accesses()),
        m_verify_proofs(verify_proofs),
        m_next_access{0},
        m_one_based{one_based},
        m_root_hash{initial_hash},
        m_hasher{} {
        if (m_accesses.empty()) {
            throw std::invalid_argument{"the access log has no accesses"};
        }
        if (m_verify_proofs) {
            if (!log.get_log_type().has_proofs()) {
                throw std::invalid_argument{"log has no proofs"};
            }
        }
    }

    /// \brief No copy constructor
    replay_state_access(const replay_state_access &) = delete;
    /// \brief No copy assignment
    replay_state_access &operator=(const replay_state_access &) = delete;
    /// \brief No move constructor
    replay_state_access(replay_state_access &&) = delete;
    /// \brief No move assignment
    replay_state_access &operator=(replay_state_access &&) = delete;
    /// \brief Default destructor
    ~replay_state_access() = default;

    void get_root_hash(machine_merkle_tree::hash_type &hash) const {
        hash = m_root_hash;
    }

    /// \brief Checks if access log was fully consumed after reset operation is finished
    void finish(void) {
        if (m_next_access != m_accesses.size()) {
            throw std::invalid_argument{"access log was not fully consumed"};
        }
    }

private:
    friend i_state_access<replay_state_access, pma_entry>;

    auto access_to_report(void) const {
        return m_next_access + m_one_based;
    }

    static void get_hash(machine_merkle_tree::hasher_type &hasher, const access_data &data,
        machine_merkle_tree::hash_type &hash) {
        get_merkle_tree_hash(hasher, data.data(), data.size(), sizeof(uint64_t), hash);
    }

    /// \brief Checks a logged word read and advances log.
    /// \param paligned Physical address in the machine state,
    /// aligned to 64-bits.
    /// \param text Textual description of the access.
    /// \returns Value read.
    uint64_t check_read_word(uint64_t paligned, const char *text) {
        return get_word_access_data(check_read(paligned, 3, text));
    }

    /// \brief Checks a logged read and advances log.
    /// \param paligned Physical address in the machine state,
    /// aligned to the access size.
    /// \param log2_size Log2 of access size.
    /// \param text Textual description of the access.
    /// \returns Value read.
    const access_data &check_read(uint64_t paligned, int log2_size, const char *text) {
        if (m_next_access >= m_accesses.size()) {
            throw std::invalid_argument{"too few accesses in log"};
        }
        const auto &access = m_accesses[m_next_access];
        if ((paligned & ((UINT64_C(1) << log2_size) - 1)) != 0) {
            throw std::invalid_argument{"access address not aligned to size"};
        }
        if (access.get_address() != paligned) {
            std::ostringstream err;
            err << "expected access " << access_to_report() << " to read " << text << " at address 0x" << std::hex
                << paligned << "(" << std::dec << paligned << ")";
            throw std::invalid_argument{err.str()};
        }
        if (log2_size < 3 || log2_size > 63) {
            throw std::invalid_argument{"invalid access size"};
        }
        if (access.get_log2_size() != log2_size) {
            throw std::invalid_argument{"expected access " + std::to_string(access_to_report()) + " to read 2^" +
                std::to_string(log2_size) + " bytes from " + text};
        }
        if (access.get_type() != access_type::read) {
            throw std::invalid_argument{"expected access " + std::to_string(access_to_report()) + " to read " + text};
        }
        if (!access.get_read().has_value()) {
            throw std::invalid_argument{
                "missing read " + std::string(text) + " data at access " + std::to_string(access_to_report())};
        }
        const auto &value_read = access.get_read().value(); // NOLINT(bugprone-unchecked-optional-access)
        if (value_read.size() != UINT64_C(1) << log2_size) {
            throw std::invalid_argument{"expected read " + std::string(text) + " data to contain 2^" +
                std::to_string(log2_size) + " bytes at access " + std::to_string(access_to_report())};
        }
        // check if logged read data hashes to the logged read hash
        hash_type computed_hash{};
        get_hash(m_hasher, value_read, computed_hash);
        if (access.get_read_hash() != computed_hash) {
            throw std::invalid_argument{"logged read data of " + std::string(text) +
                " data does not hash to the logged read hash at access " + std::to_string(access_to_report())};
        }
        if (m_verify_proofs) {
            auto proof = access.make_proof(m_root_hash);
            if (!proof.verify(m_hasher)) {
                throw std::invalid_argument{"Mismatch in root hash of access " + std::to_string(access_to_report())};
            }
        }
        m_next_access++;
        // NOLINTNEXTLINE(bugprone-unchecked-optional-access)
        return access.get_read().value();
    }

    /// \brief Checks a logged word write and advances log.
    /// \param paligned Physical address in the machine state,
    /// aligned to a 64-bit word.
    /// \param word Word value to write.
    /// \param text Textual description of the access.
    /// \returns Value read.
    void check_write_word(uint64_t paligned, uint64_t word, const char *text) {
        access_data val;
        set_word_access_data(word, val);
        check_write(paligned, val, 3, text);
    }

    /// \brief Checks a logged write and advances log.
    /// \param paligned Physical address in the machine state,
    /// aligned to the access size.
    /// \param val Value to write.
    /// \param log2_size Log2 of access size.
    /// \param text Textual description of the access.
    void check_write(uint64_t paligned, const access_data &val, int log2_size, const char *text) {
        if (m_next_access >= m_accesses.size()) {
            throw std::invalid_argument{"too few accesses in log"};
        }
        const auto &access = m_accesses[m_next_access];
        if ((paligned & ((UINT64_C(1) << log2_size) - 1)) != 0) {
            throw std::invalid_argument{"access address not aligned to size"};
        }
        if (access.get_address() != paligned) {
            std::ostringstream err;
            err << "expected access " << access_to_report() << " to write " << text << " at address 0x" << std::hex
                << paligned << "(" << std::dec << paligned << ")";
            throw std::invalid_argument{err.str()};
        }
        if (log2_size < 3 || log2_size > 63) {
            throw std::invalid_argument{"invalid access size"};
        }
        if (access.get_log2_size() != log2_size) {
            throw std::invalid_argument{"expected access " + std::to_string(access_to_report()) + " to write 2^" +
                std::to_string(log2_size) + " bytes from " + text};
        }
        if (access.get_type() != access_type::write) {
            throw std::invalid_argument{"expected access " + std::to_string(access_to_report()) + " to write " + text};
        }
        if (access.get_read().has_value()) {
            const auto &value_read = access.get_read().value(); // NOLINT(bugprone-unchecked-optional-access)
            if (value_read.size() != UINT64_C(1) << log2_size) {
                throw std::invalid_argument{"expected overwritten data from " + std::string(text) + " to contain 2^" +
                    std::to_string(log2_size) + " bytes at access " + std::to_string(access_to_report())};
            }
            // check if read data hashes to the logged read hash
            hash_type computed_hash{};
            get_hash(m_hasher, value_read, computed_hash);
            if (access.get_read_hash() != computed_hash) {
                throw std::invalid_argument{"logged read data of " + std::string(text) +
                    " does not hash to the logged read hash at access " + std::to_string(access_to_report())};
            }
        }
        if (!access.get_written_hash().has_value()) {
            throw std::invalid_argument{
                "missing written " + std::string(text) + " hash at access " + std::to_string(access_to_report())};
        }
        const auto &written_hash = access.get_written_hash().value(); // NOLINT(bugprone-unchecked-optional-access)
        // check if value being written hashes to the logged written hash
        hash_type computed_hash{};
        get_hash(m_hasher, val, computed_hash);
        if (written_hash != computed_hash) {
            throw std::invalid_argument{"value being written to " + std::string(text) +
                " does not hash to the logged written hash at access " + std::to_string(access_to_report())};
        }
        if (access.get_written().has_value()) {
            const auto &value_written = access.get_written().value(); // NOLINT(bugprone-unchecked-optional-access)
            if (value_written.size() != UINT64_C(1) << log2_size) {
                throw std::invalid_argument{"expected written " + std::string(text) + " data to contain 2^" +
                    std::to_string(log2_size) + " bytes at access " + std::to_string(access_to_report())};
            }
            // check if written data hashes to the logged written hash
            get_hash(m_hasher, value_written, computed_hash);
            if (written_hash != computed_hash) {
                throw std::invalid_argument{"logged written data of " + std::string(text) +
                    " does not hash to the logged written hash at access " + std::to_string(access_to_report())};
            }
        }
        if (m_verify_proofs) {
            auto proof = access.make_proof(m_root_hash);
            if (!proof.verify(m_hasher)) {
                throw std::invalid_argument{"Mismatch in root hash of access " + std::to_string(access_to_report())};
            }
            // Update root hash to reflect the data written by this access
            m_root_hash = proof.bubble_up(m_hasher, written_hash);
        }
        m_next_access++;
    }

    void do_push_bracket(bracket_type &type, const char *text) {}

    void do_reset_iflags_Y(void) {
        auto old_iflags = check_read_word(shadow_state_get_csr_abs_addr(shadow_state_csr::iflags), "iflags.Y");
        auto new_iflags = old_iflags & (~IFLAGS_Y_MASK);
        check_write_word(shadow_state_get_csr_abs_addr(shadow_state_csr::iflags), new_iflags, "iflags.Y");
    }

    bool do_read_iflags_Y(void) {
        auto iflags = check_read_word(shadow_state_get_csr_abs_addr(shadow_state_csr::iflags), "iflags.Y");
        return (iflags & IFLAGS_Y_MASK) != 0;
    }

    void do_write_htif_fromhost(uint64_t val) {
        check_write_word(shadow_state_get_csr_abs_addr(shadow_state_csr::htif_fromhost), val, "htif.fromhost");
    }

    void do_write_memory_with_padding(uint64_t paddr, const unsigned char *data, uint64_t data_length,
        int write_length_log2_size) {
        hasher_type hasher{};
        if (!data) {
            throw std::invalid_argument("data is null");
        }
        const uint64_t write_length = static_cast<uint64_t>(1) << write_length_log2_size;
        if (write_length < data_length) {
            throw std::invalid_argument{"write length is less than data length"};
        }
        const auto text = std::string("cmio rx buffer");
        if (m_next_access >= m_accesses.size()) {
            throw std::invalid_argument{"too few accesses in log"};
        }
        const auto &access = m_accesses[m_next_access];
        if (access.get_address() != paddr) {
            throw std::invalid_argument{
                "expected address of access " + std::to_string(access_to_report()) + " to match address of " + text};
        }
        if (access.get_log2_size() != write_length_log2_size) {
            throw std::invalid_argument{"expected access " + std::to_string(access_to_report()) + " to write 2^" +
                std::to_string(write_length_log2_size) + " bytes to " + text};
        }
        if (access.get_type() != access_type::write) {
            throw std::invalid_argument{"expected access " + std::to_string(access_to_report()) + " to write " + text};
        }
        // if read data is available then its hash and the logged read hash must match
        if (access.get_read().has_value()) {
            hash_type computed_logged_data_hash{};
            // NOLINTNEXTLINE(bugprone-unchecked-optional-access)
            get_hash(hasher, access.get_read().value(), computed_logged_data_hash);
            if (computed_logged_data_hash != access.get_read_hash()) {
                throw std::invalid_argument{"hash of read data and read hash at access " +
                    std::to_string(access_to_report()) + " does not match read hash"};
            }
        }
        if (!access.get_written_hash().has_value()) {
            throw std::invalid_argument{"write access " + std::to_string(access_to_report()) + " has no written hash"};
        }
        const auto &written_hash = access.get_written_hash().value(); // NOLINT(bugprone-unchecked-optional-access)
        // compute hash of data argument padded with zeroes
        hash_type computed_data_hash{};
        auto scratch = unique_calloc<unsigned char>(write_length, std::nothrow_t{});
        if (!scratch) {
            throw std::runtime_error("Could not allocate scratch memory");
        }
        memcpy(scratch.get(), data, data_length);
        if (write_length > data_length) {
            memset(scratch.get() + data_length, 0, write_length - data_length);
        }
        get_merkle_tree_hash(hasher, scratch.get(), write_length, sizeof(uint64_t), computed_data_hash);
        // check if logged written hash matches the computed data hash
        if (written_hash != computed_data_hash) {
            throw std::invalid_argument{"logged written hash of " + text +
                " does not match the hash of data argument at access " + std::to_string(access_to_report())};
        }
        if (access.get_written().has_value()) {
            // if written data is available then its hash and the logged written hash must match
            hash_type computed_hash;
            get_hash(hasher, access.get_written().value(), computed_hash); // NOLINT(bugprone-unchecked-optional-access)
            if (computed_hash != written_hash) {
                throw std::invalid_argument{
                    "written hash and written data mismatch at access " + std::to_string(access_to_report())};
            }
        }
        if (m_verify_proofs) {
            auto proof = access.make_proof(m_root_hash);
            if (!proof.verify(m_hasher)) {
                throw std::invalid_argument{"Mismatch in root hash of access " + std::to_string(access_to_report())};
            }
            m_root_hash = proof.bubble_up(m_hasher, written_hash);
        }
        m_next_access++;
    }
};

} // namespace cartesi

#endif
