// Copyright Cartesi and individual authors (see AUTHORS)
// SPDX-License-Identifier: LGPL-3.0-or-later
//
// This program is free software: you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option) any
// later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
// PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License along
// with this program (see COPYING). If not, see <https://www.gnu.org/licenses/>.
//

#ifndef UARCH_REPLAY_STATE_ACCESS_H
#define UARCH_REPLAY_STATE_ACCESS_H

/// \file
/// \brief State access implementation that replays recorded state accesses

#include <cassert>
#include <cstdint>
#include <cstring>
#include <ios>
#include <sstream>
#include <string>
#include <vector>

#include "access-log.h"
#include "i-accept-scoped-note.h"
#include "i-hasher.h"
#include "i-prefer-shadow-uarch-state.h"
#include "i-uarch-state-access.h"
#include "machine-merkle-tree.h"
#include "meta.h"
#include "shadow-tlb.h"
#include "shadow-uarch-state.h"
#include "uarch-constants.h"
#include "uarch-pristine-state-hash.h"

namespace cartesi {

class uarch_replay_state_access :
    public i_uarch_state_access<uarch_replay_state_access>,
    public i_accept_scoped_note<uarch_replay_state_access>,
    public i_prefer_shadow_uarch_state<uarch_replay_state_access> {
    using tree_type = machine_merkle_tree;
    using hash_type = tree_type::hash_type;
    using hasher_type = tree_type::hasher_type;
    using proof_type = tree_type::proof_type;

    ///< Access log generated by step
    const std::vector<access> &m_accesses; // NOLINT(cppcoreguidelines-avoid-const-or-ref-data-members)
    ///< Next access
    unsigned m_next_access{};

    ///< Root hash before next access
    hash_type m_root_hash;
    ///< Hasher needed to verify proofs
    hasher_type m_hasher;

public:
    /// \brief Constructor from log of word accesses.
    /// \param log Access log to be replayed
    /// \param initial_hash  Initial root hash
    explicit uarch_replay_state_access(const access_log &log, const hash_type &initial_hash) :
        m_accesses(log.get_accesses()),
        m_root_hash{initial_hash} {
        ;
    }

    /// \brief No copy constructor
    uarch_replay_state_access(const uarch_replay_state_access &) = delete;
    /// \brief No copy assignment
    uarch_replay_state_access &operator=(const uarch_replay_state_access &) = delete;
    /// \brief No move constructor
    uarch_replay_state_access(uarch_replay_state_access &&) = delete;
    /// \brief No move assignment
    uarch_replay_state_access &operator=(uarch_replay_state_access &&) = delete;
    /// \brief Default destructor
    ~uarch_replay_state_access() = default;

    void finish() {
        if (m_next_access != m_accesses.size()) {
            throw std::invalid_argument{"access log was not fully consumed"};
        }
    }

    void get_root_hash(hash_type &hash) const {
        hash = m_root_hash;
    }

private:
    static auto get_hash(hasher_type &hasher, const access_data &data) {
        hash_type hash{};
        get_merkle_tree_hash(hasher, data.data(), data.size(), machine_merkle_tree::get_word_size(), hash);
        return hash;
    }

    std::string access_to_report() const {
        auto index = m_next_access + 1;
        auto digit = index % 10;
        const char *suffix = nullptr;
        switch (digit) {
            case 1:
                suffix = "st";
                break;
            case 2:
                suffix = "nd";
                break;
            case 3:
                suffix = "rd";
                break;
            default:
                suffix = "th";
                break;
        }
        return std::to_string(index) + suffix + " access";
    }

    static constexpr const char *access_type_name(access_type type) {
        switch (type) {
            case access_type::read:
                return "read";
            case access_type::write:
                return "write";
        }
    }

    static std::pair<uint64_t, int> adjust_access(uint64_t paddr, int log2_size) {
        static_assert(cartesi::log2_size_v<uint64_t> <= machine_merkle_tree::get_log2_word_size(),
            "Merkle tree word size must not be smaller than machine word size");
        const auto log2_word_size = machine_merkle_tree::get_log2_word_size();
        const auto log2_access_size = std::max(log2_size, log2_word_size);
        const auto access_paddr = (paddr >> log2_access_size) << log2_access_size;
        return {access_paddr, log2_access_size};
    }

    const access &check_access(const char *text) {
        if (m_next_access >= m_accesses.size()) {
            throw std::invalid_argument{"log is missing access " + access_to_report() + " to " + text};
        }
        return m_accesses[m_next_access];
    }

    void check_access_type(const access &a, access_type type, const char *text) {
        if (a.get_type() != type) {
            throw std::invalid_argument{
                "expected " + access_to_report() + " to " + access_type_name(type) + " " + text};
        }
        if (type == access_type::read) {
            if (a.get_written().has_value()) {
                throw std::invalid_argument{
                    "unexpected written data in " + access_to_report() + " read access to " + text};
            }
            if (a.get_written_hash().has_value()) {
                throw std::invalid_argument{
                    "unexpected written hash in " + access_to_report() + " read access to " + text};
            }
        }
    }

    void check_access_range(const access &a, access_type type, uint64_t paddr, uint64_t log2_size, const char *text) {
        if (a.get_address() != paddr) {
            std::ostringstream err;
            err << "expected " << access_to_report() << " to " << access_type_name(type) << " " << text
                << " at address 0x" << std::hex << paddr << "(" << std::dec << paddr << ")";
            throw std::invalid_argument{err.str()};
        }
        if (a.get_log2_size() != static_cast<int>(log2_size)) {
            throw std::invalid_argument{"expected " + access_to_report() + " to " + text + " to " +
                access_type_name(type) + " 2^" + std::to_string(log2_size) + " bytes"};
        }
    }

    auto check_access_siblings_and_read_hash(const access &a, const char *text) {
        const auto proof = a.make_proof(m_root_hash);
        if (!proof.verify(m_hasher)) {
            throw std::invalid_argument{
                "siblings and read hash do not match root hash before " + access_to_report() + " to " + text};
        }
        return proof;
    }

    const auto &check_written_hash(const access &a, const hash_type &expected_hash, const char *text) {
        if (!a.get_written_hash().has_value()) {
            throw std::invalid_argument{"missing written hash of " + std::string(text) + " in " + access_to_report()};
        }
        // NOLINTBEGIN(bugprone-unchecked-optional-access)
        if (a.get_written_hash().value() != expected_hash) {
            throw std::invalid_argument{
                "written hash for " + std::string(text) + " does not match expected hash in " + access_to_report()};
        }
        return a.get_written_hash().value();
        // NOLINTEND(bugprone-unchecked-optional-access)
    }

    const auto &check_read_data(const access &a, const char *text) {
        if (!a.get_read().has_value()) {
            throw std::invalid_argument{"missing read data for " + std::string(text) + " in " + access_to_report()};
        }
        // check if logged read data hashes to the logged read hash
        // NOLINTBEGIN(bugprone-unchecked-optional-access)
        const auto computed_read_hash = get_hash(m_hasher, a.get_read().value());
        if (a.get_read_hash() != computed_read_hash) {
            throw std::invalid_argument{
                "read data for " + std::string(text) + " does not match read hash in " + access_to_report()};
        }
        return a.get_read().value();
        // NOLINTEND(bugprone-unchecked-optional-access)
    }

    void check_written_data_if_there(const access &a, const hash_type &written_hash, const char *text) {
        if (!a.get_written().has_value()) {
            return;
        }
        // NOLINTBEGIN(bugprone-unchecked-optional-access)
        if (written_hash != get_hash(m_hasher, a.get_written().value())) {
            throw std::invalid_argument{
                "written data for " + std::string(text) + " does not match written hash in " + access_to_report()};
        }
        // NOLINTEND(bugprone-unchecked-optional-access)
    }

    void check_read_data_if_there(const access &a, const char *text) {
        if (!a.get_read().has_value()) {
            return;
        }
        // NOLINTBEGIN(bugprone-unchecked-optional-access)
        if (a.get_read_hash() != get_hash(m_hasher, a.get_read().value())) {
            throw std::invalid_argument{
                "read data for " + std::string(text) + " does not match read hash in " + access_to_report()};
        }
        // NOLINTEND(bugprone-unchecked-optional-access)
    }

    void update_root_hash(const proof_type &proof, const hash_type &written_hash) {
        m_root_hash = proof.bubble_up(m_hasher, written_hash);
    }

    void check_write_access(uint64_t paddr, uint64_t log2_size, const hash_type &expected_hash, const char *text) {
        const auto &a = check_access(text);
        check_access_type(a, access_type::write, text);
        check_access_range(a, access_type::write, paddr, log2_size, text);
        const auto proof = check_access_siblings_and_read_hash(a, text);
        const auto &written_hash = check_written_hash(a, expected_hash, text);
        check_read_data_if_there(a, text);
        check_written_data_if_there(a, written_hash, text);
        update_root_hash(proof, written_hash);
        m_next_access++;
    }

    void check_write_word_access(uint64_t paddr, uint64_t val, const char *text) {
        const auto log2_size = log2_size_v<uint64_t>;
        const auto &a = check_access(text);
        check_access_type(a, access_type::write, text);
        check_access_range(a, access_type::write, paddr, log2_size, text);
        const auto proof = check_access_siblings_and_read_hash(a, text);
        auto written_data = check_read_data(a, text);
        [[maybe_unused]] const auto [access_paddr, access_log2_size] = adjust_access(paddr, log2_size);
        const auto val_offset = paddr - access_paddr;
        replace_word_access_data(val, written_data, val_offset);
        const auto &written_hash = check_written_hash(a, get_hash(m_hasher, written_data), text);
        check_written_data_if_there(a, written_hash, text);
        update_root_hash(proof, written_hash);
        m_next_access++;
    }

    void check_write_reg_access(machine_reg reg, uint64_t val) {
        check_write_word_access(machine_reg_address(reg), val, machine_reg_get_name(reg));
    }

    uint64_t check_read_word_access(uint64_t paddr, const char *text) {
        const auto log2_size = log2_size_v<uint64_t>;
        const auto &a = check_access(text);
        check_access_type(a, access_type::read, text);
        check_access_range(a, access_type::read, paddr, log2_size, text);
        std::ignore = check_access_siblings_and_read_hash(a, text);
        const auto &read_data = check_read_data(a, text);
        [[maybe_unused]] const auto [access_paddr, access_log2_size] = adjust_access(paddr, log2_size);
        const auto val_offset = paddr - access_paddr;
        const auto val = get_word_access_data(read_data, val_offset);
        m_next_access++;
        return val;
    }

    uint64_t check_read_reg_access(machine_reg reg) {
        return check_read_word_access(machine_reg_address(reg), machine_reg_get_name(reg));
    }

    auto get_write_tlb_slot_hash(uint64_t vaddr_page, uint64_t vp_offset, uint64_t pma_index) {
        // Writes to TLB slots have to be atomic.
        // We can only do atomic writes of entire Merkle tree nodes.
        // Therefore, TLB slot must have a power-of-two size, or at least be aligned to it.
        static_assert(SHADOW_TLB_SLOT_SIZE == sizeof(shadow_tlb_slot), "shadow TLB slot size is wrong");
        static_assert((UINT64_C(1) << SHADOW_TLB_SLOT_LOG2_SIZE) == SHADOW_TLB_SLOT_SIZE,
            "shadow TLB slot log2 size is wrong");
        static_assert(SHADOW_TLB_SLOT_LOG2_SIZE >= machine_merkle_tree::get_log2_word_size(),
            "shadow TLB slot must fill at least an entire Merkle tree word");
        shadow_tlb_slot slot_data{};
        shadow_tlb_fill_slot(vaddr_page, vp_offset, pma_index, slot_data);
        hash_type slot_hash{};
        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
        get_merkle_tree_hash(m_hasher, reinterpret_cast<uint8_t *>(&slot_data), sizeof(slot_data),
            machine_merkle_tree::get_word_size(), slot_hash);
        return slot_hash;
    }

    // -----
    // i_prefer_shadow_uarch_state interface implementation
    // -----
    friend i_prefer_shadow_uarch_state<uarch_replay_state_access>;

    uint64_t do_read_shadow_uarch_state(shadow_uarch_state_what what) {
        return check_read_reg_access(machine_reg_enum(what));
    }

    void do_write_shadow_uarch_state(shadow_uarch_state_what what, uint64_t val) {
        check_write_reg_access(machine_reg_enum(what), val);
    }

    // -----
    // i_uarch_state_access interface implementation
    // -----
    friend i_uarch_state_access<uarch_replay_state_access>;

    uint64_t do_read_word(uint64_t paddr) {
        return check_read_word_access(paddr, machine::get_what_name(paddr));
    }

    void do_write_word(uint64_t paddr, uint64_t val) {
        check_write_word_access(paddr, val, machine::get_what_name(paddr));
    }

    // NOLINTNEXTLINE(readability-convert-member-functions-to-static)
    void do_putchar(uint8_t /*c*/) {
        ; // do nothing
    }

    // NOLINTNEXTLINE(readability-convert-member-functions-to-static)
    void do_mark_dirty_page(uint64_t /*paddr*/, uint64_t /*pma_index*/) {
        ; // do nothing
    }

    void do_reset_uarch() {
        check_write_access(UARCH_STATE_START_ADDRESS, UARCH_STATE_LOG2_SIZE, uarch_pristine_state_hash, "uarch.state");
    }

    void do_write_tlb(TLB_set_index set_index, uint64_t slot_index, uint64_t vaddr_page, uint64_t vp_offset,
        uint64_t pma_index) {
        const auto slot_paddr = shadow_tlb_get_abs_addr(set_index, slot_index);
        const auto slot_hash = get_write_tlb_slot_hash(vaddr_page, vp_offset, pma_index);
        check_write_access(slot_paddr, SHADOW_TLB_SLOT_LOG2_SIZE, slot_hash, "tlb.slot");
    }

    // NOLINTNEXTLINE(readability-convert-member-functions-to-static)
    constexpr const char *do_get_name() const {
        return "uarch_replay_state_access";
    }
};

} // namespace cartesi

#endif
