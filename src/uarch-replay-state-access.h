// Copyright Cartesi and individual authors (see AUTHORS)
// SPDX-License-Identifier: LGPL-3.0-or-later
//
// This program is free software: you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option) any
// later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
// PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License along
// with this program (see COPYING). If not, see <https://www.gnu.org/licenses/>.
//

#ifndef UARCH_REPLAY_STATE_ACCESS_H
#define UARCH_REPLAY_STATE_ACCESS_H

/// \file
/// \brief State access implementation that replays recorded state accesses

#include <cassert>
#include <cstdint>
#include <cstring>
#include <ios>
#include <sstream>
#include <string>
#include <vector>

#include "access-log.h"
#include "i-hasher.h"
#include "i-state-access.h"
#include "i-uarch-state-access.h"
#include "machine-merkle-tree.h"
#include "meta.h"
#include "shadow-uarch-state.h"
#include "uarch-bridge.h"
#include "uarch-constants.h"
#include "uarch-pristine-state-hash.h"

namespace cartesi {

class uarch_replay_state_access : public i_uarch_state_access<uarch_replay_state_access> {
    using tree_type = machine_merkle_tree;
    using hash_type = tree_type::hash_type;
    using hasher_type = tree_type::hasher_type;
    using proof_type = tree_type::proof_type;

    ///< Access log generated by step
    const std::vector<access> &m_accesses; // NOLINT(cppcoreguidelines-avoid-const-or-ref-data-members)
    ///< Next access
    unsigned m_next_access{};

    ///< Root hash before next access
    hash_type m_root_hash;
    ///< Hasher needed to verify proofs
    hasher_type m_hasher;

public:
    /// \brief Constructor from log of word accesses.
    /// \param log Access log to be replayed
    /// \param initial_hash  Initial root hash
    explicit uarch_replay_state_access(const access_log &log, const hash_type &initial_hash) :
        m_accesses(log.get_accesses()),
        m_root_hash{initial_hash} {
        if (m_accesses.empty()) {
            throw std::invalid_argument{"the access log has no accesses"};
        }
    }

    /// \brief No copy constructor
    uarch_replay_state_access(const uarch_replay_state_access &) = delete;
    /// \brief No copy assignment
    uarch_replay_state_access &operator=(const uarch_replay_state_access &) = delete;
    /// \brief No move constructor
    uarch_replay_state_access(uarch_replay_state_access &&) = delete;
    /// \brief No move assignment
    uarch_replay_state_access &operator=(uarch_replay_state_access &&) = delete;
    /// \brief Default destructor
    ~uarch_replay_state_access() = default;

    void finish() {
        if (m_next_access != m_accesses.size()) {
            throw std::invalid_argument{"access log was not fully consumed"};
        }
    }

    void get_root_hash(hash_type &hash) const {
        hash = m_root_hash;
    }

private:
    std::string access_to_report() const {
        auto index = m_next_access + 1;
        switch (index) {
            case 1:
                return "1st access";
            case 2:
                return "2nd access";
            case 3:
                return "3rd access";
            default:
                return std::to_string(index) + "th access";
        }
    }

    static void get_hash(hasher_type &hasher, const access_data &data, hash_type &hash) {
        get_merkle_tree_hash(hasher, data.data(), data.size(), machine_merkle_tree::get_word_size(), hash);
    }

    /// \brief Checks a logged word read and advances log.
    /// \param paligned Physical address in the machine state,
    /// aligned to 64-bits.
    /// \param text Textual description of the access.
    /// \returns Value read.
    uint64_t check_read(uint64_t paligned, const char *text) {
        static_assert(machine_merkle_tree::get_log2_word_size() >= log2_size<uint64_t>::value,
            "Merkle tree word size must be at least as large as a machine word");
        if ((paligned & (sizeof(uint64_t) - 1)) != 0) {
            throw std::invalid_argument{"address not aligned to word size"};
        }
        if (m_next_access >= m_accesses.size()) {
            throw std::invalid_argument{"too few accesses in log"};
        }
        const auto &access = m_accesses[m_next_access];
        if (access.get_type() != access_type::read) {
            throw std::invalid_argument{"expected " + access_to_report() + " to read " + text};
        }
        if (access.get_address() != paligned) {
            std::ostringstream err;
            err << "expected " << access_to_report() << " to read " << text << " address 0x" << std::hex << paligned
                << "(" << std::dec << paligned << ")";
            throw std::invalid_argument{err.str()};
        }
        if (access.get_log2_size() != log2_size<uint64_t>::value) {
            throw std::invalid_argument{"expected " + access_to_report() + " to read 2^" +
                std::to_string(machine_merkle_tree::get_log2_word_size()) + " bytes from " + text};
        }
        if (!access.get_read().has_value()) {
            throw std::invalid_argument{"missing read " + std::string(text) + " data at " + access_to_report()};
        }
        // NOLINTBEGIN(bugprone-unchecked-optional-access)
        const auto &read_data = access.get_read().value();
        if (read_data.size() != machine_merkle_tree::get_word_size()) {
            throw std::invalid_argument{"expected read " + std::string(text) + " data to contain 2^" +
                std::to_string(machine_merkle_tree::get_log2_word_size()) + " bytes at " + access_to_report()};
        }
        // check if logged read data hashes to the logged read hash
        hash_type computed_read_hash{};
        get_hash(m_hasher, read_data, computed_read_hash);
        if (access.get_read_hash() != computed_read_hash) {
            throw std::invalid_argument{"logged read data of " + std::string(text) +
                " data does not hash to the logged read hash at " + access_to_report()};
        }
        auto proof = access.make_proof(m_root_hash);
        if (!proof.verify(m_hasher)) {
            throw std::invalid_argument{"Mismatch in root hash of " + access_to_report()};
        }
        m_next_access++;
        const uint64_t pleaf_aligned = paligned & ~(machine_merkle_tree::get_word_size() - 1);
        const int word_offset = static_cast<int>(paligned - pleaf_aligned);
        return get_word_access_data(read_data, word_offset);
        // NOLINTEND(bugprone-unchecked-optional-access)
    }

    /// \brief Checks a logged word write and advances log.
    /// \param paligned Physical address in the machine state,
    /// aligned to a 64-bit word.
    /// \param word Word value to write.
    /// \param text Textual description of the access.
    void check_write(uint64_t paligned, uint64_t word, const char *text) {
        static_assert(machine_merkle_tree::get_log2_word_size() >= log2_size<uint64_t>::value,
            "Merkle tree word size must be at least as large as a machine word");
        if ((paligned & (sizeof(uint64_t) - 1)) != 0) {
            throw std::invalid_argument{"paligned not aligned to word size"};
        }
        if (m_next_access >= m_accesses.size()) {
            throw std::invalid_argument{"too few accesses in log"};
        }
        const auto &access = m_accesses[m_next_access];
        if (access.get_type() != access_type::write) {
            throw std::invalid_argument{"expected " + access_to_report() + " to write " + text};
        }
        if (access.get_address() != paligned) {
            std::ostringstream err;
            err << "expected " << access_to_report() << " to write " << text << " to address 0x" << std::hex << paligned
                << "(" << std::dec << paligned << ")";
            throw std::invalid_argument{err.str()};
        }
        if (access.get_log2_size() != log2_size<uint64_t>::value) {
            throw std::invalid_argument{"expected " + access_to_report() + " to write 2^" +
                std::to_string(machine_merkle_tree::get_log2_word_size()) + " bytes to " + text};
        }
        // NOLINTBEGIN(bugprone-unchecked-optional-access)
        // check read
        if (!access.get_read().has_value()) {
            throw std::invalid_argument{"missing read " + std::string(text) + " data at " + access_to_report()};
        }
        const auto &read_data = access.get_read().value();
        if (read_data.size() != machine_merkle_tree::get_word_size()) {
            throw std::invalid_argument{"expected overwritten data from " + std::string(text) + " to contain 2^" +
                std::to_string(access.get_log2_size()) + " bytes at " + access_to_report()};
        }
        // check if read data hashes to the logged read hash
        hash_type computed_read_hash{};
        get_hash(m_hasher, read_data, computed_read_hash);
        if (access.get_read_hash() != computed_read_hash) {
            throw std::invalid_argument{"logged read data of " + std::string(text) +
                " does not hash to the logged read hash at " + access_to_report()};
        }
        // check write
        if (!access.get_written_hash().has_value()) {
            throw std::invalid_argument{"missing written " + std::string(text) + " hash at " + access_to_report()};
        }
        const auto &written_hash = access.get_written_hash().value();
        if (!access.get_written().has_value()) {
            throw std::invalid_argument{"missing written " + std::string(text) + " data at " + access_to_report()};
        }
        const auto &written_data = access.get_written().value();
        if (written_data.size() != read_data.size()) {
            throw std::invalid_argument{"expected written " + std::string(text) + " data to contain 2^" +
                std::to_string(access.get_log2_size()) + " bytes at " + access_to_report()};
        }
        // check if written data hashes to the logged written hash
        hash_type computed_written_hash{};
        get_hash(m_hasher, written_data, computed_written_hash);
        if (written_hash != computed_written_hash) {
            throw std::invalid_argument{"logged written data of " + std::string(text) +
                " does not hash to the logged written hash at " + access_to_report()};
        }
        // check if word being written matches the logged data
        const uint64_t pleaf_aligned = paligned & ~(machine_merkle_tree::get_word_size() - 1);
        const int word_offset = static_cast<int>(paligned - pleaf_aligned);
        const uint64_t logged_word = get_word_access_data(written_data, word_offset);
        if (word != logged_word) {
            throw std::invalid_argument{"value being written to " + std::string(text) +
                " does not match the logged written value at " + access_to_report()};
        }
        // check if logged written data differs from the logged read data only by the written word
        access_data expected_written_data(read_data);                       // make a copy of read data
        replace_word_access_data(word, expected_written_data, word_offset); // patch with written word
        if (written_data != expected_written_data) {
            throw std::invalid_argument{"logged written data of " + std::string(text) +
                " doesn't differ from the logged read data only by the written word at " + access_to_report()};
        }
        // NOLINTEND(bugprone-unchecked-optional-access)
        // check proof
        auto proof = access.make_proof(m_root_hash);
        if (!proof.verify(m_hasher)) {
            throw std::invalid_argument{"Mismatch in root hash of " + access_to_report()};
        }
        // Update root hash to reflect the data written by this access
        m_root_hash = proof.bubble_up(m_hasher, written_hash);
        m_next_access++;
    }

    friend i_uarch_state_access<uarch_replay_state_access>;

    // NOLINTNEXTLINE(readability-convert-member-functions-to-static)
    void do_push_bracket(bracket_type /*type*/, const char * /*text*/) {}

    // NOLINTNEXTLINE(readability-convert-member-functions-to-static)
    int do_make_scoped_note(const char * /*text*/) {
        return 0;
    }

    uint64_t do_read_x(int reg) {
        return check_read(machine_reg_address(machine_reg::uarch_x0, reg), "uarch.x");
    }

    void do_write_x(int reg, uint64_t val) {
        assert(reg != 0);
        check_write(machine_reg_address(machine_reg::uarch_x0, reg), val, "uarch.x");
    }

    uint64_t do_read_pc() {
        return check_read(machine_reg_address(machine_reg::uarch_pc), "uarch.pc");
    }

    void do_write_pc(uint64_t val) {
        check_write(machine_reg_address(machine_reg::uarch_pc), val, "uarch.pc");
    }

    uint64_t do_read_cycle() {
        return check_read(machine_reg_address(machine_reg::uarch_cycle), "uarch.uarch_cycle");
    }

    void do_write_cycle(uint64_t val) {
        check_write(machine_reg_address(machine_reg::uarch_cycle), val, "uarch.cycle");
    }

    bool do_read_halt_flag() {
        return check_read(machine_reg_address(machine_reg::uarch_halt_flag), "uarch.halt_flag") != 0;
    }

    void do_set_halt_flag() {
        check_write(machine_reg_address(machine_reg::uarch_halt_flag), static_cast<uint64_t>(true), "uarch.halt_flag");
    }

    void do_reset_halt_flag() {
        check_write(machine_reg_address(machine_reg::uarch_halt_flag), static_cast<uint64_t>(false), "uarch.halt_flag");
    }

    uint64_t do_read_word(uint64_t paddr) {
        assert((paddr & (sizeof(uint64_t) - 1)) == 0);
        // Get the name of the state register identified by this address
        const auto *name = uarch_bridge::get_register_name(paddr);
        if (name == nullptr) {
            // this is a regular memory access
            name = "memory";
        }
        return check_read(paddr, name);
    }

    void do_write_word(uint64_t paddr, uint64_t data) {
        assert((paddr & (sizeof(uint64_t) - 1)) == 0);
        // Get the name of the state register identified by this address
        const auto *name = uarch_bridge::get_register_name(paddr);
        if (name == nullptr) {
            // this is a regular memory access
            name = "memory";
        }
        check_write(paddr, data, name);
    }

    void do_reset_state() {
        hasher_type hasher;
        auto text = std::string("uarchState");
        if (m_next_access >= m_accesses.size()) {
            throw std::invalid_argument{"too few accesses in log"};
        }
        const auto &access = m_accesses[m_next_access];
        if (access.get_address() != UARCH_STATE_START_ADDRESS) {
            throw std::invalid_argument{
                "expected address of " + access_to_report() + " to be the start address of the uarch state"};
        }
        if (access.get_log2_size() != UARCH_STATE_LOG2_SIZE) {
            throw std::invalid_argument{"expected " + access_to_report() + " to write 2^" +
                std::to_string(UARCH_STATE_LOG2_SIZE) + " bytes to " + text};
        }
        if (access.get_type() != access_type::write) {
            throw std::invalid_argument{"expected " + access_to_report() + " to write " + text};
        }
        // NOLINTBEGIN(bugprone-unchecked-optional-access)
        if (access.get_read().has_value()) {
            // if read data is available then its hash and the logged read hash must match
            hash_type computed_hash;
            get_hash(hasher, access.get_read().value(), computed_hash);
            if (computed_hash != access.get_read_hash()) {
                throw std::invalid_argument{
                    "hash of read data and read hash at " + access_to_report() + " does not match read hash"};
            }
        }
        if (!access.get_written_hash().has_value()) {
            throw std::invalid_argument{"write " + access_to_report() + " has no written hash"};
        }
        const auto &written_hash = access.get_written_hash().value();
        if (written_hash != uarch_pristine_state_hash) {
            throw std::invalid_argument{
                "expected written hash of " + access_to_report() + " to be the start hash of the pristine uarch state"};
        }
        if (access.get_written().has_value()) {
            // if written data is available then its hash and the logged written hash must match
            hash_type computed_hash;
            get_hash(hasher, access.get_written().value(), computed_hash);
            if (computed_hash != written_hash) {
                throw std::invalid_argument{"written hash and written data mismatch at " + access_to_report()};
            }
        }
        // NOLINTEND(bugprone-unchecked-optional-access)
        // check proof
        auto proof = access.make_proof(m_root_hash);
        if (!proof.verify(m_hasher)) {
            throw std::invalid_argument{"Mismatch in root hash of " + access_to_report()};
        }
        // Update root hash to reflect the data written by this access
        m_root_hash = proof.bubble_up(m_hasher, written_hash);
        m_next_access++;
    }
};

} // namespace cartesi

#endif
